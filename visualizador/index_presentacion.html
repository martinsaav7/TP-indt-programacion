<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming - Algoritmos</title>
    <link rel="stylesheet" href="Styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>

    <header class="navbar">
        <div class="logo-container">
            <i class="fas fa-gamepad logo-icon"></i>
            <span class="site-name">Programming</span>
        </div>
    </header>

    <div class="main-content">
        <aside class="sidebar">
            <nav>
                <h3>Algoritmos</h3>
                <ul>
                    <li><a href="#bubble-sort">Bubble Sort</a></li>
                    <li><a href="#insertion-sort">Insertion Sort</a></li>
                    <li><a href="#selection-sort">Selection Sort</a></li>
                </ul>
            </nav>
        </aside>

        <main class="content-body">
            <h1>Conceptos Generales sobre Algoritmos en Python</h1>
            <p>
                Los algoritmos son el **corazón de la programación**, definiendo una serie de pasos finitos y bien definidos para resolver un problema. En el contexto de **Python**, un lenguaje de programación de alto nivel conocido por su legibilidad, la implementación de algoritmos se vuelve notablemente clara y concisa.
            </p>

            <p>
                La **eficiencia** de un algoritmo se mide generalmente por su **complejidad temporal** y **espacial**, lo que se describe utilizando la **notación de la Gran O** ($O(n)$). Elegir el algoritmo adecuado puede hacer una diferencia significativa en el rendimiento de una aplicación, especialmente al manejar grandes volúmenes de datos.
            </p>
            
            <section id="bubble-sort">
                <h2> <a href="index.html" >Bubble Sort</a></h2>
                <p>
                    El **Bubble Sort** (Ordenamiento de Burbuja) es un algoritmo de ordenamiento simple que funciona revisando repetidamente la lista a ordenar e intercambiando los elementos adyacentes si están en el orden equivocado. Se caracteriza por su simplicidad, pero también por su baja eficiencia, teniendo una complejidad promedio y en el peor caso de $O(n^2)$.
                </p>
                <div class="example-code">
                    <h4>Ejemplo básico en Python:</h4>
                    <pre><code>
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
                    </code></pre>
                </div>
            </section>

            <section id="insertion-sort">
                <h2> <a href="index.html" >Insertion Sort</a></h2>           
                <p>
                    El **Insertion Sort** (Ordenamiento por Inserción) construye el arreglo final ordenado un elemento a la vez. Es mucho menos eficiente en listas grandes que los algoritmos avanzados como Quick Sort, pero es eficiente para datos que ya están sustancialmente ordenados o para colecciones pequeñas. Su complejidad en el peor caso sigue siendo $O(n^2)$.
                </p>
            </section>
            
            <section id="selection-sort">
                <h2> <a href="index.html" >Selection Sort</a></h2>
                
                <p>
                    El **Selection Sort** (Ordenamiento por Selección) mejora en cierta medida a Bubble Sort al minimizar el número de swaps. Recorre la lista repetidamente para encontrar el elemento más pequeño y lo coloca al principio. Al igual que los anteriores, su complejidad es $O(n^2)$.
                </p>
            </section>

        </main>
    </div>

</body>
</html>